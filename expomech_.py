# -*- coding: utf-8 -*-
"""ExpoMech .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wDnjHHLQYE1Uyq7pxn0cgkjsJAVQXVrD
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
T = 0  # Clipping bound for gap for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    n = len(u_values)
    sensitivity = 1  # Sensitivity Î” = 1 for test
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(n)

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

# Function to generate and plot new utility values
def generate_and_plot():
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute the probability for each utility value in D
    prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

    # Compute the probability for each utility value in D'
    prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Create a dataframe to display results
    results = pd.DataFrame({
        'u_values_D': u_values_D,
        'u_values_D_prime': u_values_D_prime,
        'prob_D': prob_D,
        'prob_D_prime': prob_D_prime,
        'ratio': ratios
    })

    print(results)

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Apply the Bounded Gap Exponential Mechanism
    index, gamma = bounded_gap_exp_mech(u_values_D, epsilon, T)
    print(f"Selected index: {index}, Gap (gamma): {gamma}")

    # Range for the epsilon values to compare
    epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

    # Create a plot
    plt.figure(figsize=(10, 6))

    # Plot the log of the division ratios
    plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

    # Plot the epsilon values as horizontal lines
    for eps in epsilon_values:
        plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

    # Limit the y-axis
    plt.ylim(-1.5, 1.5)

    # Labels and title
    plt.xlabel('Index')
    plt.ylabel('log(P(D)/P(D\'))')
    plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
    plt.legend(loc='upper right')
    plt.grid(True)

    # Plot
    plt.show()

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    rounded_range = round(log_ratio_range, 10)  # rounding to avoid precision errors
    print(f"Range of log ratios: {log_ratio_range}")
    print(f"Rounded range of log ratios: {rounded_range}")
    print(f"Is the range within epsilon? {'Yes' if rounded_range <= epsilon else 'No'}")

# Generate and plot new utility values
generate_and_plot()