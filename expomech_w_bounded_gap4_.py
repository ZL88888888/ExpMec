# -*- coding: utf-8 -*-
"""ExpoMech_w_bounded_gap4  .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wDnjHHLQYE1Uyq7pxn0cgkjsJAVQXVrD
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Set gamma_s to half T
    gamma_s = T / 2

    # Compute the probability for each utility value in D using formula (6)
    prob_D = np.exp(gamma_s - theta) / (1 + np.exp(gamma_s - theta))**2

    # Compute the probability for each utility value in D' using formula (6)
    prob_D_prime = np.exp(gamma_s - theta_prime) / (1 + np.exp(gamma_s - theta_prime))**2

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 31, 30)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()