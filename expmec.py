# -*- coding: utf-8 -*-
"""ExpMec.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qexxBFe8i-z-Ei82fra9hxBTkh4z2tT4
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50

# Generate 10 utility values for dataset D
np.random.seed(42)
u_values_D = np.random.rand(n)
rand_num = np.random.uniform(-1,1,50)

# Generate 10 utility values for dataset D'
u_values_D_prime = u_values_D + rand_num

# Compute the probability for each utility value in D
prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

# Compute the probability for each utility value in D'
prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

# Compute the division of probabilities
ratios = prob_D / prob_D_prime

# Display results
results = pd.DataFrame({
    'u_values_D': u_values_D,
    'u_values_D_prime': u_values_D_prime,
    'prob_D': prob_D,
    'prob_D_prime': prob_D_prime,
    'ratio': ratios
})

print(results)

# Compute the log of the probabilities
log_ratios = np.log(ratios)

# The range for the epsilon values to compare
epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

# Plot
plt.figure(figsize=(10, 6))

# Plot the log
plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

# Plot the epsilon values as horizontal lines
for eps in epsilon_values:
    plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

# Limit the y-axis to the range
plt.ylim(-1.5, 1.5)

# Labels and title
plt.xlabel('Index')
plt.ylabel('log(P(D)/P(D\'))')
plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
plt.legend(loc='upper right')
plt.grid(True)

plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50

# Function to generate and plot new utility values
def generate_and_plot():
    # Generate 10 utility values for dataset D
    u_values_D = np.random.rand(n)
    rand_num = np.random.randint(2, size=50)*2-1

    # Generate 10 utility values for dataset D'
    u_values_D_prime = u_values_D + rand_num


    # Compute the probability for each utility value in D
    prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

    # Compute the probability for each utility value in D'
    prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Create a dataframe to display results
    results = pd.DataFrame({
        'u_values_D': u_values_D,
        'u_values_D_prime': u_values_D_prime,
        'prob_D': prob_D,
        'prob_D_prime': prob_D_prime,
        'ratio': ratios
    })


    print(results)

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Range for the epsilon values to compare
    epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

    # Create a plot
    plt.figure(figsize=(10, 6))

    # Plot the log of the 2 division ratios
    plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

    # Plot the epsilon values as horizontal lines
    for eps in epsilon_values:
        plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

    # Limit the y-axis
    plt.ylim(-1.5, 1.5)

    # Labels and title
    plt.xlabel('Index')
    plt.ylabel('log(P(D)/P(D\'))')
    plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
    plt.legend(loc='upper right')
    plt.grid(True)

    # Show the plot
    plt.show()

# Generate and plot new utility values
generate_and_plot()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50

# Function to generate and plot new utility values
def generate_and_plot():
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute the probability for each utility value in D
    prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

    # Compute the probability for each utility value in D'
    prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Create a dataframe to display results
    results = pd.DataFrame({
        'u_values_D': u_values_D,
        'u_values_D_prime': u_values_D_prime,
        'prob_D': prob_D,
        'prob_D_prime': prob_D_prime,
        'ratio': ratios
    })

    print(results)

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Range for the epsilon values to compare
    epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

    # Plot
    plt.figure(figsize=(10, 6))

    # Plot the log of the division ratios
    plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

    # Plot the epsilon values as horizontal lines
    for eps in epsilon_values:
        plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

    # Limit the y-axis
    plt.ylim(-1.5, 1.5)

    # Labels and title
    plt.xlabel('Index')
    plt.ylabel('log(P(D)/P(D\'))')
    plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
    plt.legend(loc='upper right')
    plt.grid(True)

    # Show the plot
    plt.show()

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Range of log ratios: {log_ratio_range}")
    print(f"Is the range within epsilon? {'Yes' if log_ratio_range <= epsilon else 'No'}")

# Generate and plot new utility values
generate_and_plot()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50

# Function to generate and plot new utility values
def generate_and_plot():
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute the probability for each utility value in D
    prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

    # Compute the probability for each utility value in D'
    prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Create a dataframe to display results
    results = pd.DataFrame({
        'u_values_D': u_values_D,
        'u_values_D_prime': u_values_D_prime,
        'prob_D': prob_D,
        'prob_D_prime': prob_D_prime,
        'ratio': ratios
    })

    print(results)

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Range for the epsilon values to compare
    epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

    # Plot
    plt.figure(figsize=(10, 6))

    # Plot the log of the division ratios
    plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

    # Plot the epsilon values as horizontal lines
    for eps in epsilon_values:
        plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

    # Limit the y-axis
    plt.ylim(-1.5, 1.5)

    # Labels and title
    plt.xlabel('Index')
    plt.ylabel('log(P(D)/P(D\'))')
    plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
    plt.legend(loc='upper right')
    plt.grid(True)

    # Show the plot
    plt.show()

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    rounded_range = round(log_ratio_range, 10)  # rounding to avoid precision errors
    print(f"Range of log ratios: {log_ratio_range}")
    print(f"Rounded range of log ratios: {rounded_range}")
    print(f"Is the range within epsilon? {'Yes' if rounded_range <= epsilon else 'No'}")

# Generate and plot new utility values
generate_and_plot()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
T = 0  # Clipping bound for gap for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    n = len(u_values)
    sensitivity = 1  # Sensitivity Δ = 1 for test
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(n)

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

# Function to generate and plot new utility values
def generate_and_plot():
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute the probability for each utility value in D
    prob_D = np.exp(epsilon * u_values_D / 2) / np.sum(np.exp(epsilon * u_values_D / 2))

    # Compute the probability for each utility value in D'
    prob_D_prime = np.exp(epsilon * u_values_D_prime / 2) / np.sum(np.exp(epsilon * u_values_D_prime / 2))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Create a dataframe to display results
    results = pd.DataFrame({
        'u_values_D': u_values_D,
        'u_values_D_prime': u_values_D_prime,
        'prob_D': prob_D,
        'prob_D_prime': prob_D_prime,
        'ratio': ratios
    })

    print(results)

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Apply the Bounded Gap Exponential Mechanism
    index, gamma = bounded_gap_exp_mech(u_values_D, epsilon, T)
    print(f"Selected index: {index}, Gap (gamma): {gamma}")

    # Range for the epsilon values to compare
    epsilon_values = [0.5 * epsilon, epsilon, -0.5 * epsilon, -epsilon]

    # Create a plot
    plt.figure(figsize=(10, 6))

    # Plot the log of the division ratios
    plt.plot(range(n), log_ratios, label='log(P(D)/P(D\'))', color='orange')

    # Plot the epsilon values as horizontal lines
    for eps in epsilon_values:
        plt.axhline(y=eps, color='r', linestyle='--', label=f'{eps} epsilon')

    # Limit the y-axis
    plt.ylim(-1.5, 1.5)

    # Labels and title
    plt.xlabel('Index')
    plt.ylabel('log(P(D)/P(D\'))')
    plt.title('Logarithm of Probability Ratios for Exponential Mechanism')
    plt.legend(loc='upper right')
    plt.grid(True)

    # Plot
    plt.show()

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    rounded_range = round(log_ratio_range, 10)  # rounding to avoid precision errors
    print(f"Range of log ratios: {log_ratio_range}")
    print(f"Rounded range of log ratios: {rounded_range}")
    print(f"Is the range within epsilon? {'Yes' if rounded_range <= epsilon else 'No'}")

# Generate and plot new utility values
generate_and_plot()

"""For each candidate i in the set { 1 , … , 𝑛 }, compute a score x i​. The score is given by the utility value μ(D,ω i​) plus Gumbel noise: x i​← 2Δ/ϵ μ(D,ω i​)​+Gumbel(0).
Find Top Scores is to identify the indices s and t of the highest and the second-highest scores, respectively.
Calculate the gap γ between the highest and the second-highest scores:  γ s​←x s​−x t​.
If the gap γ ​is less than T, return the candidate with the highest score and the gap γ. Otherwise, return the candidate with the highest score and the threshold T


t= 0.1 - 1. plot the range.
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.log(np.sum(np.exp(mu)))
    theta = mu - vi

    # Compute the probability for each utility value in D
    prob_D = 1 / (1 + np.exp(T - theta))

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.log(np.sum(np.exp(mu_prime)))
    theta_prime = mu_prime - vi_prime

    # Compute the probability for each utility value in D'
    prob_D_prime = 1 / (1 + np.exp(T - theta_prime))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 1.0, 10)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute the probability for each utility value in D
    prob_D = 1 / (1 + np.exp(T - theta))

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Compute the probability for each utility value in D'
    prob_D_prime = 1 / (1 + np.exp(T - theta_prime))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 1.0, 10)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute the probability for each utility value in D
    prob_D = 1 / (1 + np.exp(T - theta))

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Compute the probability for each utility value in D'
    prob_D_prime = 1 / (1 + np.exp(T - theta_prime))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0, 10, 50)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute the probability for each utility value in D
    prob_D = 1 / (1 + np.exp(T - theta))

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Compute the probability for each utility value in D'
    prob_D_prime = 1 / (1 + np.exp(T - theta_prime))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(10, 100, 10)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    # u_values_D = np.random.rand(n)
    u_values_D = np.ones(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute the probability for each utility value in D
    prob_D = 1 / (1 + np.exp(T - theta))

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Compute the probability for each utility value in D'
    prob_D_prime = 1 / (1 + np.exp(T - theta_prime))

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0.2, 100, 20)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

"""gamma halfT     2 py files"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    # Generate n utility values for dataset D
    u_values_D = np.random.rand(n)
    # Generate n utility values for dataset D' with a shift of +/-1
    u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

    # Compute θ values for D
    mu = u_values_D / (2 * sensitivity / epsilon)
    vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
    theta = mu - vi

    # Compute θ' values for D'
    mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
    vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
    theta_prime = mu_prime - vi_prime

    # Set gamma_s to half T
    gamma_s = T / 2

    # Compute the probability for each utility value in D using formula (6)
    prob_D = np.exp(gamma_s - theta) / (1 + np.exp(gamma_s - theta))**2

    # Compute the probability for each utility value in D' using formula (6)
    prob_D_prime = np.exp(gamma_s - theta_prime) / (1 + np.exp(gamma_s - theta_prime))**2

    # Compute the division of probabilities
    ratios = prob_D / prob_D_prime

    # Compute the log of the probability ratios
    log_ratios = np.log(ratios)

    # Calculate the range of log ratios
    log_ratio_range = log_ratios.max() - log_ratios.min()
    print(f"Log ratio range for T={T}: {log_ratio_range} (should be within 2)")

    return log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 31, 30)
log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding ranges of log ratios:")
for T, range_value in zip(T_values, log_ratio_ranges):
    print(f"T = {T:.1f}, range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(log_ratio_ranges)
min_range = min(log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, log_ratio_ranges, marker='o', label='Range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Range of log ratios')
plt.title('Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test
num_experiments = 50  # Number of experiments to run for each T

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    max_log_ratio_range = 0

    for _ in range(num_experiments):
        # Generate n utility values for dataset D
        u_values_D = np.random.rand(n)
        # Generate n utility values for dataset D' with a shift of +/-1
        u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

        # Compute θ values for D
        mu = u_values_D / (2 * sensitivity / epsilon)
        vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
        theta = mu - vi

        # Compute θ' values for D'
        mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
        vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
        theta_prime = mu_prime - vi_prime

        # Set gamma_s to half T
        gamma_s = T / 2

        # Compute the probability for each utility value in D using formula (6)
        prob_D = np.exp(gamma_s - theta) / (1 + np.exp(gamma_s - theta))**2

        # Compute the probability for each utility value in D' using formula (6)
        prob_D_prime = np.exp(gamma_s - theta_prime) / (1 + np.exp(gamma_s - theta_prime))**2

        # Compute the division of probabilities
        ratios = prob_D / prob_D_prime

        # Compute the log of the probability ratios
        log_ratios = np.log(ratios)

        # Calculate the range of log ratios
        log_ratio_range = log_ratios.max() - log_ratios.min()

        # Update the maximum log ratio range found
        if log_ratio_range > max_log_ratio_range:
            max_log_ratio_range = log_ratio_range

    print(f"Max log ratio range for T={T}: {max_log_ratio_range} (should be within 2)")

    return max_log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 20, 100)
max_log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding maximum ranges of log ratios:")
for T, range_value in zip(T_values, max_log_ratio_ranges):
    print(f"T = {T:.1f}, max range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(max_log_ratio_ranges)
min_range = min(max_log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, max_log_ratio_ranges, marker='o', label='Max range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Max range of log ratios')
plt.title('Max Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()