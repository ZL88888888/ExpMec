# -*- coding: utf-8 -*-
"""ExpoMech_w_bounded_gap5  .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wDnjHHLQYE1Uyq7pxn0cgkjsJAVQXVrD
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Parameters
epsilon = 1
n = 50
sensitivity = 1  # Sensitivity Δ = 1 for test
num_experiments = 50  # Number of experiments to run for each T

# Gumbel noise generation
def gumbel_noise(size):
    return np.random.gumbel(0, 1, size)

# Bounded Gap Exponential Mechanism function
def bounded_gap_exp_mech(u_values, epsilon, T):
    x_values = u_values / (2 * sensitivity / epsilon) + gumbel_noise(len(u_values))

    s, t = np.argsort(x_values)[-2:]  # Find indices of top 2 values
    gamma_s = x_values[s] - x_values[t]

    if gamma_s < T:
        return s, gamma_s
    else:
        return s, T

def compute_log_ratio_range(T):
    max_log_ratio_range = 0

    for _ in range(num_experiments):
        # Generate n utility values for dataset D
        u_values_D = np.random.rand(n)
        # Generate n utility values for dataset D' with a shift of +/-1
        u_values_D_prime = u_values_D + (np.random.randint(0, 2, size=n) * 2 - 1)

        # Compute θ values for D
        mu = u_values_D / (2 * sensitivity / epsilon)
        vi = np.array([np.log(np.sum(np.exp(mu[np.arange(n) != i]))) for i in range(n)])
        theta = mu - vi

        # Compute θ' values for D'
        mu_prime = u_values_D_prime / (2 * sensitivity / epsilon)
        vi_prime = np.array([np.log(np.sum(np.exp(mu_prime[np.arange(n) != i]))) for i in range(n)])
        theta_prime = mu_prime - vi_prime

        # Set gamma_s to half T
        gamma_s = T / 2

        # Compute the probability for each utility value in D using formula (6)
        prob_D = np.exp(gamma_s - theta) / (1 + np.exp(gamma_s - theta))**2

        # Compute the probability for each utility value in D' using formula (6)
        prob_D_prime = np.exp(gamma_s - theta_prime) / (1 + np.exp(gamma_s - theta_prime))**2

        # Compute the division of probabilities
        ratios = prob_D / prob_D_prime

        # Compute the log of the probability ratios
        log_ratios = np.log(ratios)

        # Calculate the range of log ratios
        log_ratio_range = log_ratios.max() - log_ratios.min()

        # Update the maximum log ratio range found
        if log_ratio_range > max_log_ratio_range:
            max_log_ratio_range = log_ratio_range

    print(f"Max log ratio range for T={T}: {max_log_ratio_range} (should be within 2)")

    return max_log_ratio_range

# Define the T values
T_values = np.linspace(0.1, 15, 200)
max_log_ratio_ranges = [compute_log_ratio_range(T) for T in T_values]

# Print the values
print("T values and corresponding maximum ranges of log ratios:")
for T, range_value in zip(T_values, max_log_ratio_ranges):
    print(f"T = {T:.1f}, max range of log ratios = {range_value}")

# Check if the range of log ratios is within 2
max_range = max(max_log_ratio_ranges)
min_range = min(max_log_ratio_ranges)
is_within_range = max_range - min_range <= 2
print(f"Max range of log ratios: {max_range}")
print(f"Min range of log ratios: {min_range}")
print(f"Range of log ratios within 2: {is_within_range}")

# Create a plot
plt.figure(figsize=(10, 6))
plt.plot(T_values, max_log_ratio_ranges, marker='o', label='Max range of log ratios')

# Add labels and title
plt.xlabel('T values')
plt.ylabel('Max range of log ratios')
plt.title('Max Range of Log Ratios for Different T values')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()